# Программирование на Си 2 и 3 семестры, BMSTU(Bauman Moscow), IU7, 2017

### Автоперенос из GitLab(кафедры), если есть какие-то проблемы или недочеты- отпишите

<h1>ПЕРВАЯ ЧАСТЬ.</h1>
<h1>Лабораторная работа 1.</h1><br/><br/>

<h3>Задача 1</h3>
Даны основания равнобедренной трапеции и угол при большем основании. Найти 
площадь трапеции.
<br/>

<h3>Задача 2</h3>
<pre>
include studio.h<br/>
main{}<br/>
(<br/>
 int s;<br/>
 s: = 56;<br/>
 print (Year has s weeks)<br/>
)
</pre>
<br/>

<h3>Задача 3</h3>
Смешано v<sub>1</sub> литров воды температуры t<sub>1</sub> с v<sub>2</sub> 
литрами воды температуры t<sub>2</sub>. Найти объем и температуры образовавшейся смеси.
<br/><br/>

<h3>Задача 4</h3>
Определите номер подъезда и этажа по номеру квартиры девятиэтажного дома, 
считая, что на каждом этаже ровно 4 квартиры, а нумерация квартир начинается с 
первого подъезда
<br/><br/><br/><br/>

<h1>Лабораторная работа 2.</h1><br/><br/>

<h3>Задача 1</h3>

Последовательность Фибоначчи определяется так:<br/>
F<sub>0</sub> = 0, F<sub>1</sub> = 1, F<sub>k</sub> = F<sub>k-1</sub> + F<sub>k-2</sub>
при k >= 2.<br/>
Дано n, вычислить F<sub>n</sub>.

<h3>Задача 2</h3>

Дана точка и треугольник заданный координатами своих вершин. Определить лежит ли 
точка внутри, на границе или вне этого треугольника

<h3>Задача 3</h3>

Вычислит с точность eps:<br/>
- приближенное значение функции s(x);<br/>
- точное значение функции f(x);<br/>
- абсолютную |f(x)-s(x)| и |f(x)-s(x)|/|f(x)| относительную ошибки приближенного
значения.<br/><br/>

s(x) = x + x<sup>3</sup>/(2*3) + 3*x<sup>5</sup>/(2*4*5) + 
3*5*x<sup>7</sup>/(2*4*6*7) + 3*5*7*x<sup>9</sup>/(2*4*6*8*9) + ...<br/>
|x| < 1, f(x) = arcsin(x)

<h3>Утилита gcov</h3>

Утилита gcov используется (в том числе) для анализа покрытия кода тестами. Информация,
которая получается в результате работы этой утилиты, позволяет ответить на следующие
вопросы:<br/>

- как часто выполняется каждая строка кода;<br/>
- какие строки кода не выполняются;<br/>
- какой процент строк кода покрыт тестами (для каждого файла);<br/>
- какой процент ветвлений покрыт тестами (для каждого файла).<br/><br/>

gcov обрабатывает программы, которые были получены только с помощью компилятора gcc. 
При сборке программы желательно выключить оптимизацию с помощью ключа «-O0» и 
добавить следующие ключи «-fprofile-arcs» и «-ftest-coverage».<br/><br/>

Два последних ключа вынуждают компилятор добавить в исполняемый файл программы 
дополнительный код, который во время ее выполнения собирает статистическую 
информацию и сохраняется ее в служебные файлы. gcov использует эти файлы для создания 
«аннотированного» листинга исходного кода программы, который содержит информацию о 
частоте выполнения каждой строки.
<br/><br/><br/><br/>

<h1>Лабораторная работа 3.</h1><br/><br/>

<h3>Задача 1</h3>

Пользователь вводит целые числа, по окончании ввода чисел нажимает 
Ctrl-Z и Enter или вводит букву.<br/><br/>

<h4>Написать программу, которая:</h4>
Определяет количество локальных максимумов в последовательности (Элемент
последовательности называется локальным максимумом, если он строго больше
предыдущего и последующего элемента последовательности. Первый и последний
элемент последовательности не являются локальными максимумами.);<br/>

<h4>Требования к решению задачи:</h4>
- Прототип функции, которая реализует решение задачи, должен выглядеть следующим
образом:<br/>

<pre>int process(FILE *f [, прочие выходные параметры]);</pre>

- Функция process возвращает 0 в случае успешного решения задачи и отрицательный
код ошибки в противном случае (например, -1 – входных данных нет и т.д.). Для
каждого кода ошибки задается мнемоническое имя с помощью директивы define.<br/>
- При решении любой задачи из варианта 1 два цикла ввода и массивы не использовать.<br/>
- Необходимо подготовить наборы тестовых данных по классам эквивалентности.
Каждый набор разместить в текстовом файле.<br/>

<h3>Задача 2</h3>

<h4>Написать программу, которая считывает из текстового файла вещественные числа и
выполняет над ними некоторые вычисления: </h4>
Проверить выполняется ли правило «трех сигм» для чисел;<br/>

<h4>Требования к решению задачи:</h4>
- При решении задачи выделить несколько функций.<br/>
- При решении задачи массивы не использовать.<br/>
- Имя файла берется из аргументов командной строки.<br/>
- Предусмотреть обработку ошибок.<br/>
- Решение любой из этих задач выполняется минимум за два просмотра файла.<br/>
- Подготовить тестовые данные, демонстрирующие правильную работу программы.<br/>
<br/><br/><br/><br/>

<h1>Лабораторная работа 4.</h1><br/><br/>

Написать программу, которая запрашивает у пользователя элементы целочисленного
статического массива и выполняет его обработку. Максимальное количество элементов,
которое может ввести пользователь, равно 10.<br/>

<h3>Реализуйте функции для:</h3>
- нахождения суммы четных и произведения нечетных элементов массива;<br/>
- перезаписи в другой массив всех элементов, которые больше среднего
арифметического элементов исходного массива;<br/>
- удаления из массива всех отрицательных элементов;<br/>
- добавления после элементов, значение которых равно указанному числу (вводится по
запросу), суммы элементов, предшествующих ему;<br/>
- обмена в массиве максимального элемента среди четных и минимального элемента
среди нечетных;<br/>
- записи на место максимального элемента, кратного 3, суммы элементов,
заканчивающихся на 3;<br/>
- упорядочивания элементов, расположенных между минимальным и максимальным
элементами массива (включая эти элементы).
<br/><br/><br/><br/>

<h1>Лабораторная работа 5.</h1><br/><br/>

Написать программу, которая считывает из текстового файла целые числа в 
статический массив и Вычислить значение 
min(x[0]*x[1], x[1]*x[2],x[2]*x[3], ..., x[n-3]*x[n-2], x[n-2]*x[n-1]).<br/>
Где x[i] - элементы массива x из n элементов.
<br/><br/>

Максимальный размер статического массива – 100 элементов. При считывании 
элементов массива из файла необходимо предусмотреть контроль переполнения 
массива. Если в файле содержится больше 100 элементов, программа должна выдать 
соответствующее сообщение и обработать считанные 100 элементов. С оставшимися 
элементами программа ничего делать не должна.<br/><br/>

Имя файла передается через параметры командной строки.
<br/><br/><br/><br/>

<h1>Лабораторная работа 6.</h1><br/><br/>

Необходимо реализовать многофайловый проект на основе 5-ой лабораторной работы. 
Заголовочные файлы оформляются с использованием "include guard". Допущения
(если они есть), сделанные при реализации функций, проверяются с помощью утверждений.
<br/><br/>

Модульные тесты для функции, выполняющей решение основной задачи, оформляются 
как отдельный проект. Модульные тесты организуются способом, который рассказывался 
на последнем семинаре по ОПИ (в moodle есть пример).
<br/><br/>

Для сборки обоих проектов используется утилита make. Оба проекта
(основной и модульные тесты) собираются как с отладочной информацией, 
так и без нее. Запуск модульных тестов из make-файла сразу после сборки 
тестов оценивается отдельно.<br/><br/>

Сборка проекта в Qt Creator организуется с помощью написанного (или написанных) 
make-файла (файлов).
<br/><br/><br/><br/>

<h1>ВТОРАЯ ЧАСТЬ.</h1>

<h1>Лабораторная работа 7.</h1><br/><br/>

Написать программу, которая упорядочивает (сортирует) массив.<br/>

Данные в массив считываются из текстового файла. Количество элементов в файле не 
указано. Память под массив выделяется динамически. Число элементов в массиве 
определяется в первом проходе по текстовому файлу, во время второго прохода числа 
считываются в массив.<br/>

Полученный после сортировки массив записывается в другой файл.<br/>

Возможно, что перед сортировкой элементы массива могут быть отфильтрованы с помощью
функции-фильтра.<br/>

Функция-фильтр работает следующим образом:
- определяет количество элементов массива, которые удовлетворяют заданному
условию;
- выделяет память под соответствующее количество элементов;
- копирует элементы, удовлетворяющие условию, из старого массива в новый.
<br/>

<h4>Функция-фильтр имеет следующее название и прототип:</h4><br/>

<pre>int key(const int *pb_src, const int *pe_src, int **pb_dst, int **pe_dst);</pre>
<br/><br/>

Функция сортировки реализуется универсальной (т.е. имеет одинаковый прототип с 
функцией qsort из стандартной библиотеки (stdlib.h)) и называется mysort.<br/>

Все параметры (имена файлов, необходимость фильтрации) передаются через аргументы
командной строки.<br/>

<h4>Формат запуска приложения должен быть следующим:</h4><br/>

<pre>app.exe in_file out_file [f]</pre><br/>

Для всех функций реализуются модульные тесты (отдельный проект).<br/>

При защите лабораторной работы необходимо продемонстрировать отчет утилиты Dr.
Memory, свидетельствующий об отсутствии ошибок при работе с памятью. Отчеты Dr.
Memory под версионный контроль не помещаются.<br/>

Кроме того, необходимо сравнить время работы реализованного алгоритма сортировки 
и qsort. Постараться найти примеры, когда ваша реализация лучше. Результаты 
представить в виде графиков (рисунки в формате PNG, оси подписаны). Графики 
разместить в Wiki на отдельной странице. Графики можно строить любыми средствами
(например, в Excel). 
<br/><br/><br/><br/>

<h1>Лабораторная работа 8.</h1><br/><br/>

Написать программу для работы с матрицами, которая реализует сложение матриц, 
умножение матриц и вычисление определителя с помощью разложения по строке.
<br/><br/>

Память под матрицы выделяется динамически 2 методом:

<pre>
double **data = calloc(n, sizeof(double*));<br/>
    if (!data)<br/>
        return NULL;<br/><br/>

    for (int i = 0; i < n; i++)<br/>
    {<br/>
        data[i] = malloc(m * sizeof(double));<br/>
    }<br/>
</pre>
<br/><br/>

Исходные матрицы читаются из файла, результирующие матрицы записываются в файл. 
Один файл содержит одну матрицу. Количество строк и столбцов матрицы указывается 
в первой строчке файла<br/>

Тестирование выполняется с помощью сравнения полученного результата с ожидаемым. 
При этом нужно помнить, что сравнивать вещественные числа на равенство можно 
только с заданной точностью.<br/>

Имена файлов и выполняемая операция указывается через параметры командной строки.
<br/><br/>

<h4>Формат запуска приложения должен быть следующим:</h4><br/>

<pre> app.exe action mtr_1.txt [mtr_2.txt] res.txt </pre>
<br/><br/>

Возможные значения action:<br>
* a сложение;<br/>
* m умножение;<br/>
* o операция по варианту (для нее mtr_2.txt не указывается).
<br/><br/><br/><br/>

<h1>Лабораторная работа 9.</h1><br/><br/>

<h4>Задача 1</h4>
Реализовать указанные строковые функции.
1. strpbrk
2. strspn
3. strcspn
4. strchr
5. strrchr
6. strdup
7. strndup

Имена функций, которые реализуются самостоятельно, начинаются с префикса “my_”
(если нужно реализовать функцию strpbrk, в программе она должна 
называться my_strpbrk).<br/>

Эта задача подразумевает только реализацию указанных функций и модульных тестов 
к ним(т.е. никакого отдельного приложения для работы с реализованными функциями 
можно не писать). При этом в модульных тестах нужно сравнить поведение
(спецификацию) своей функции и соответствующей стандартной.<br/>

<h5>Замечание 1</h5>
Функция strdup становится доступной только при указании стандарта gnu99
(т.е. –std=gnu99).<br/>

<h5>Замечание 2</h5>
Функция strndup в библиотеке компилятора MinGW не реализована. 
Для ее тестирования пишутся модульные тесты, сравнение с реализацией из 
библиотеки не выполняется.<br/>

<h5>Замечание 3.</h5>
Для компилятора gcc из MSYS2 «замечание 2» не проверялось<br/>

<h4>Задача 2</h4>
Необходимо реализовать следующие функции:<br/>

- Чтения строки из текстового файла. Строка должна читаться целиком
(т.е. до символа EOL или EOF) за один вызов функции.<br/>
<pre>ssize_t getline(char **lineptr, size_t *n, FILE *stream);</pre><br/>
ИЛИ<br/><br/>
<pre>ssize_t getdelim(char **lineptr, size_t *n, int delimiter, FILE *stream);
</pre>
<br/><br/>

Для реализации этих функций запрещается использовать посимвольное чтение из файла. 
Вместо этого, следует завести статический или динамический буфер небольшого
(например, 128 байт) размера, чтение в этот буфер выполнять с помощью fgets, а 
прочитанные данные из буфера переписывать в результирующую строку. Память под 
результирующую строку можно выделять с помощью функции realloc.<br/>

Имена функций, которые реализуются самостоятельно, начинаются с префикса “my_”<br/>

- Замены в строке указанной непустой подстроки произвольной длины на другую 
подстроку произвольной длины (возможно пустую). Память под результирующую строку 
выделяется динамически.<br/>
<pre>char* str_replace(const char *source, const char *serach, const char *replace);
</pre>
<br/><br/>

С помощью реализованных функций обработать текстовый файл, в котором выполнить 
замену всех вхождений указанной подстроки на заданную. В файле необходимо 
обработать все строки. Преобразованные строки записать в новый файл.<br/>

<h5>Пример</h5>
В строке "aaaa" заменяем подстроку "aa" на "bbb". После замены получаем "bbbbbb".

<h5>Все параметры передаются как аргументы командной строки.</h5>
<pre>app.exe in.txt out.txt –s search –r replace</pre>
<br/><br/><br/><br/>

<h1>Лабораторная работа 10.</h1><br/><br/>

<h3>Задачи на работу с одним элементом списка</h3>
<h4>Необходимо решить любые две задачи.</h4>
- Напишите функцию поиска элемента в списке (нужна функция сравнения элементов). (1)
<br/>

<pre>
node_t* find(node_t *head, const void *data, int (*comparator)(const void*, const void *));
</pre>

- Напишите функцию pop_front, которая возвращает указатель на данные из элемента,
который расположен в "голове" списка. При этом из списка сам элемент удаляется. (1)
<br/>

<pre>void* pop_front(node_t **head);</pre>

- Напишите функцию pop_end, которая возвращает указатель на данные из элемента,
который расположен в "хвосте" списка. При этом из списка сам элемент удаляется. (1)
<br/>

<pre>void* pop_back(node_t **head);</pre>

- Напишите функцию insert, которая вставляет элемент перед указанным элементом списка
(в качестве параметров указываются адреса обоих элементов). (2)
<br/>

<pre>void insert(node_t **head, node_t *elem, node_t *before);</pre>
<br/><br/>

<h3>Задачи на работу с целым списком</h3>
<h4>Необходимо решить одну любую задачу.</h4>
- Напишите функцию copy, которая по указанному списку создает его копию (данные при
этом не копируются). (1)
<br/>

<pre>
int copy(node_t *head, node_t **new_head);
// функция возвращает код ошибки, потому что она выделяет память
</pre>

- Напишите функцию append, которая получает два списка а и b, добавляет список b в
конец a. Список b при этом оказывается пустым. (1)
<br/>

<pre>void append(node_t **head_a, node_t **head_b);</pre>

- Напишите функцию remove_duplicates, которая получает упорядоченный список и
оставляет в нем лишь первые вхождения каждого элемента. Совпадение определяется с
помощью функции сравнения элементов. При удалении элемента списка данные не
удаляются. (2)
<br/>

<pre>void remove_duplicates(node_t **head);</pre>

- Напишите функцию reverse, которая обращает список. Идеи реализации:
o Использование pop_front и двух списков. (1)
o Использование 3-х указателей на соседние элементы списка. (2)
o Рекурсия. (2)
<br/>

<pre>
node_t* reverse(node_t *head);
// возвращается «новая» голова
</pre>
<br/><br/>

<h3>Сортировка списка</h3>

<pre>
node_t* sort(node_t *head, int (*comparator)(const void *, const void *));
// возвращается «новая» голова
</pre>

<h4>Необходимо реализовать одну из двух сортировок.</h4>
- Сортировка вставками
<br/>

Напишите функцию sorted_insert, которая получает упорядоченный список, и элемент,
который нужно вставить в этот список, чтобы не нарушить его упорядоченности.

<pre>void sorted_insert(node_t **head, node_t *element);</pre>

Напишите функцию sort, которая получает список и упорядочивает его по возрастанию,
используя функцию sorted_insert. (3)

- Сортировка слиянием
<br/>

Напишите функцию front_back_split, которая получает список и делит его на две половины.
Если в списке нечетное число элементов, "серединный" элемент должен попасть в первую
половину.

<pre>void front_back_split(node_t* head, node_t** back);</pre>

Напишите функцию sorted_merge, которая получает два упорядоченных списка и объединяет
их в один.

<pre>
node_t* sorted_merge(node_t **head_a, node_t **head_b);
// Списки становятся пустыми, элементы из них «переходят» в уорядоченный
</pre>

Используя функции front_back_split и sorted_merge напишите функцию sort, которая
реализует рекурсивный алгоритм сортировки слиянием. (4)
