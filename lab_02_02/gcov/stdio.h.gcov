        -:    0:Source:c:/mingw/include/stdio.h
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:/*
        -:    2: * stdio.h
        -:    3: *
        -:    4: * Definitions of types and prototypes of functions for operations on
        -:    5: * standard input and standard output streams.
        -:    6: *
        -:    7: * $Id: stdio.h,v 0e4f78dbc1ba 2016/06/17 14:16:01 keithmarshall $
        -:    8: *
        -:    9: * Written by Colin Peters <colin@bird.fu.is.saga-u.ac.jp>
        -:   10: * Copyright (C) 1997-2005, 2007-2010, 2014-2016, MinGW.org Project.
        -:   11: *
        -:   12: *
        -:   13: * Permission is hereby granted, free of charge, to any person obtaining a
        -:   14: * copy of this software and associated documentation files (the "Software"),
        -:   15: * to deal in the Software without restriction, including without limitation
        -:   16: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   17: * and/or sell copies of the Software, and to permit persons to whom the
        -:   18: * Software is furnished to do so, subject to the following conditions:
        -:   19: *
        -:   20: * The above copyright notice, this permission notice, and the following
        -:   21: * disclaimer shall be included in all copies or substantial portions of
        -:   22: * the Software.
        -:   23: *
        -:   24: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   25: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   26: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
        -:   27: * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   28: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   29: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF OR OTHER
        -:   30: * DEALINGS IN THE SOFTWARE.
        -:   31: *
        -:   32: * NOTE: The file manipulation functions provided by Microsoft seem to
        -:   33: * work with either slash (/) or backslash (\) as the directory separator;
        -:   34: * (this is consistent with Microsoft's own documentation, on MSDN).
        -:   35: *
        -:   36: */
        -:   37:#ifndef _STDIO_H
        -:   38:#pragma GCC system_header
        -:   39:
        -:   40:/* When including <wchar.h>, some of the definitions and declarations
        -:   41: * which are nominally provided in <stdio.h> must be duplicated.  Rather
        -:   42: * than require duplicated maintenance effort, we provide for partial
        -:   43: * inclusion of <stdio.h> by <wchar.h>; only when not included in
        -:   44: * this partial fashion...
        -:   45: */
        -:   46:#ifndef __WCHAR_H_SOURCED__
        -:   47: /*
        -:   48:  * ...which is exclusive to <wchar.h>, do we assert the multiple
        -:   49:  * inclusion guard for <stdio.h> itself.
        -:   50:  */
        -:   51:#define _STDIO_H
        -:   52:#endif
        -:   53:
        -:   54:/* All the headers include this file.
        -:   55: */
        -:   56:#include <_mingw.h>
        -:   57:
        -:   58:#ifndef RC_INVOKED
        -:   59:/* POSIX stipulates that the following set of types, (as identified by
        -:   60: * __need_TYPENAME macros), shall be defined consistently with <stddef.h>;
        -:   61: * by defining the appropriate __need_TYPENAME macros, we may selectively
        -:   62: * obtain the required definitions by inclusion of <stddef.h>, WITHOUT
        -:   63: * automatic exposure of any of its additional content.
        -:   64: */
        -:   65:#define __need_NULL
        -:   66:#define __need_size_t
        -:   67:#define __need_wchar_t
        -:   68:#define __need_wint_t
        -:   69:#include <stddef.h>
        -:   70:
        -:   71:#if _POSIX_C_SOURCE >= 200809L
        -:   72: /* Similarly, for types defined in <sys/types.h>, (which are explicitly
        -:   73:  * dependent on the POSIX.1-2008 feature test)...
        -:   74:  */
        -:   75:# define __need_off_t
        -:   76:# define __need_ssize_t
        -:   77:#endif
        -:   78:#if !(defined __STRICT_ANSI__ || defined (__NO_MINGW_LFS)) \
        -:   79: && defined (__MSVCRT__)
        -:   80: /* ...while this is required to support our fseeko64() and ftello64()
        -:   81:  * implementations, (neither of which is in any way standardized)...
        -:   82:  */
        -:   83:# define __need___off64_t
        -:   84:#endif
        -:   85:/* It is sufficient to test for just one define from each of the two
        -:   86: * preceding groups...
        -:   87: */
        -:   88:#if defined __need_off_t || defined __need___off64_t
        -:   89: /* ...to identify a requirement for selective inclusion of one or more
        -:   90:  * of these type definitions from "sys/types.h"; (note that we use the
        -:   91:  * #include "..." form here, to ensure that we get the correct header
        -:   92:  * file, relative to the location of this <stdio.h>).
        -:   93:  */
        -:   94:# include "sys/types.h"
        -:   95:#endif
        -:   96:
        -:   97:#ifndef __VALIST
        -:   98: /* Also similarly, for the va_list type, defined in "stdarg.h"
        -:   99:  */
        -:  100:# if defined __GNUC__ && __GNUC__ >= 3
        -:  101:#  define __need___va_list
        -:  102:#  include "stdarg.h"
        -:  103:#  define __VALIST __builtin_va_list
        -:  104:# else
        -:  105:#  define __VALIST char *
        -:  106:# endif
        -:  107:#endif
        -:  108:#endif	/* ! RC_INVOKED */
        -:  109:
        -:  110:#ifdef _STDIO_H
        -:  111:/* Flags for the iobuf structure
        -:  112: */
        -:  113:#define _IOREAD 	1	/* currently reading */
        -:  114:#define _IOWRT		2	/* currently writing */
        -:  115:#define _IORW	   0x0080	/* opened as "r+w" */
        -:  116:
        -:  117:/* The three standard file pointers provided by the run time library.
        -:  118: * NOTE: These will go to the bit-bucket silently in GUI applications!
        -:  119: */
        -:  120:#define STDIN_FILENO	0
        -:  121:#define STDOUT_FILENO	1
        -:  122:#define STDERR_FILENO	2
        -:  123:
        -:  124:/* Returned by various functions on end of file condition or error.
        -:  125: */
        -:  126:#define EOF	      (-1)
        -:  127:
        -:  128:#endif	/* _STDIO_H */
        -:  129:
        -:  130:/* The maximum length of a file name.  It may be better to use the Windows'
        -:  131: * GetVolumeInformation() function in preference to this constant, but hey,
        -:  132: * this works!  Note that <io.h> also defines it, but we don't guard it, so
        -:  133: * that the compiler has a chance to catch inconsistencies.
        -:  134: *
        -:  135: * FIXME: Right now, we define this unconditionally for both full <stdio.h>
        -:  136: * inclusion, and for partial inclusion on behalf of <wchar.h>, (which needs
        -:  137: * it for some non-ANSI structure declarations).  The conditions under which
        -:  138: * <wchar.h> needs this require review, because defining it as a consequence
        -:  139: * of including <wchar.h> alone may violate strict ANSI conformity.
        -:  140: */
        -:  141:#define FILENAME_MAX  (260)
        -:  142:
        -:  143:#ifdef _STDIO_H
        -:  144:/* The maximum number of files that may be open at once. I have set this to
        -:  145: * a conservative number. The actual value may be higher.
        -:  146: */
        -:  147:#define FOPEN_MAX      (20)
        -:  148:
        -:  149:/* After creating this many names, tmpnam and tmpfile return NULL
        -:  150: */
        -:  151:#define TMP_MAX      32767
        -:  152:
        -:  153:/* Tmpnam, tmpfile and, sometimes, _tempnam try to create
        -:  154: * temp files in the root directory of the current drive
        -:  155: * (not in pwd, as suggested by some older MS doc's).
        -:  156: * Redefining these macros does not effect the CRT functions.
        -:  157: */
        -:  158:#define _P_tmpdir   "\\"
        -:  159:#ifndef __STRICT_ANSI__
        -:  160:#define P_tmpdir _P_tmpdir
        -:  161:#endif
        -:  162:#define _wP_tmpdir  L"\\"
        -:  163:
        -:  164:/* The maximum size of name (including NUL) that will be put in the user
        -:  165: * supplied buffer caName for tmpnam.
        -:  166: * Inferred from the size of the static buffer returned by tmpnam
        -:  167: * when passed a NULL argument. May actually be smaller.
        -:  168: */
        -:  169:#define L_tmpnam (16)
        -:  170:
        -:  171:#define _IOFBF		0x0000	/* full buffered */
        -:  172:#define _IOLBF		0x0040	/* line buffered */
        -:  173:#define _IONBF		0x0004	/* not buffered */
        -:  174:
        -:  175:#define _IOMYBUF	0x0008	/* stdio malloc()'d buffer */
        -:  176:#define _IOEOF		0x0010	/* EOF reached on read */
        -:  177:#define _IOERR		0x0020	/* I/O error from system */
        -:  178:#define _IOSTRG 	0x0040	/* Strange or no file descriptor */
        -:  179:#ifdef _POSIX_SOURCE
        -:  180:# define _IOAPPEND	0x0200
        -:  181:#endif
        -:  182:
        -:  183:/* The buffer size as used by setbuf such that it is equivalent to
        -:  184: * (void) setvbuf(fileSetBuffer, caBuffer, _IOFBF, BUFSIZ).
        -:  185: */
        -:  186:#define BUFSIZ		   512
        -:  187:
        -:  188:/* Constants for nOrigin indicating the position relative to which fseek
        -:  189: * sets the file position.  Defined unconditionally since ISO and POSIX
        -:  190: * say they are defined here.
        -:  191: */
        -:  192:#define SEEK_SET	     0
        -:  193:#define SEEK_CUR	     1
        -:  194:#define SEEK_END	     2
        -:  195:
        -:  196:#endif	/* _STDIO_H */
        -:  197:
        -:  198:#ifndef RC_INVOKED
        -:  199:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  200:/* The structure underlying the FILE type; this should be defined when
        -:  201: * including either <stdio.h> or <wchar.h>.  If both header include guards
        -:  202: * are now in place, then we must currently be including <stdio.h> in its
        -:  203: * own right, having already processed this block during a prior partial
        -:  204: * inclusion by <wchar.h>; there is no need to process it a second time.
        -:  205: *
        -:  206: * Some believe that nobody in their right mind should make use of the
        -:  207: * internals of this structure. Provided by Pedro A. Aranda Gutiirrez
        -:  208: * <paag@tid.es>.
        -:  209: */
        -:  210:typedef struct _iobuf
        -:  211:{
        -:  212:  char	*_ptr;
        -:  213:  int	 _cnt;
        -:  214:  char	*_base;
        -:  215:  int	 _flag;
        -:  216:  int	 _file;
        -:  217:  int	 _charbuf;
        -:  218:  int	 _bufsiz;
        -:  219:  char	*_tmpfname;
        -:  220:} FILE;
        -:  221:
        -:  222:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -:  223:#ifdef _STDIO_H
        -:  224:/* Content to be exposed only when including <stdio.h> in its own right;
        -:  225: * these will not be exposed when __WCHAR_H_SOURCE__ is defined, as will
        -:  226: * be the case when <stdio.h> is included indirectly, by <wchar.h>
        -:  227: *
        -:  228: *
        -:  229: * The standard file handles
        -:  230: */
        -:  231:#ifndef __DECLSPEC_SUPPORTED
        -:  232:
        -:  233:extern FILE (*_imp___iob)[];	/* A pointer to an array of FILE */
        -:  234:
        -:  235:#define _iob (*_imp___iob)	/* An array of FILE */
        -:  236:
        -:  237:#else /* __DECLSPEC_SUPPORTED */
        -:  238:
        -:  239:__MINGW_IMPORT FILE _iob[];	/* An array of FILE imported from DLL. */
        -:  240:
        -:  241:#endif /* __DECLSPEC_SUPPORTED */
        -:  242:
        -:  243:#define stdin	(&_iob[STDIN_FILENO])
        -:  244:#define stdout	(&_iob[STDOUT_FILENO])
        -:  245:#define stderr	(&_iob[STDERR_FILENO])
        -:  246:
        -:  247:/* Need to close the current _STDIO_H specific block here...
        -:  248: */
        -:  249:#endif
        -:  250:/* ...because, we need this regardless of the inclusion mode...
        -:  251: */
        -:  252:_BEGIN_C_DECLS
        -:  253:
        -:  254:#ifdef _STDIO_H
        -:  255:/* ...then revert to _STDIO_H specific mode, to declare...
        -:  256: *
        -:  257: *
        -:  258: * File Operations
        -:  259: */
        -:  260:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fopen (const char *, const char *);
        -:  261:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * freopen (const char *, const char *, FILE *);
        -:  262:_CRTIMP __cdecl __MINGW_NOTHROW  int    fflush (FILE *);
        -:  263:_CRTIMP __cdecl __MINGW_NOTHROW  int    fclose (FILE *);
        -:  264:
        -:  265:/* Note: Microsoft also declares remove & rename (but not their wide char
        -:  266: * variants) in <io.h>; since duplicate prototypes are acceptable, provided
        -:  267: * they are consistent, we simply declare them here anyway, while allowing
        -:  268: * the compiler to check consistency as appropriate.
        -:  269: */
        -:  270:_CRTIMP __cdecl __MINGW_NOTHROW  int    remove (const char *);
        -:  271:_CRTIMP __cdecl __MINGW_NOTHROW  int    rename (const char *, const char *);
        -:  272:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * tmpfile (void);
        -:  273:_CRTIMP __cdecl __MINGW_NOTHROW  char * tmpnam (char *);
        -:  274:
        -:  275:#ifndef __STRICT_ANSI__
        -:  276:_CRTIMP __cdecl __MINGW_NOTHROW  char *_tempnam (const char *, const char *);
        -:  277:_CRTIMP __cdecl __MINGW_NOTHROW  int   _rmtmp (void);
        -:  278:_CRTIMP __cdecl __MINGW_NOTHROW  int   _unlink (const char *);
        -:  279:
        -:  280:#if __MSVCRT_VERSION__>=__MSVCR80_DLL
        -:  281:/* The following pair of non-ANSI functions require a non-free version of
        -:  282: * the Microsoft runtime; neither is provided by any MSVCRT.DLL variant.
        -:  283: */
        -:  284:_CRTIMP __cdecl __MINGW_NOTHROW  void  _lock_file(FILE *);
        -:  285:_CRTIMP __cdecl __MINGW_NOTHROW  void  _unlock_file(FILE *);
        -:  286:#endif
        -:  287:
        -:  288:#ifndef NO_OLDNAMES
        -:  289:_CRTIMP __cdecl __MINGW_NOTHROW  char * tempnam (const char *, const char *);
        -:  290:_CRTIMP __cdecl __MINGW_NOTHROW  int    rmtmp (void);
        -:  291:_CRTIMP __cdecl __MINGW_NOTHROW  int    unlink (const char *);
        -:  292:#endif
        -:  293:#endif /* __STRICT_ANSI__ */
        -:  294:
        -:  295:_CRTIMP __cdecl __MINGW_NOTHROW  int    setvbuf (FILE *, char *, int, size_t);
        -:  296:_CRTIMP __cdecl __MINGW_NOTHROW  void   setbuf (FILE *, char *);
        -:  297:
        -:  298:/* Formatted Output
        -:  299: *
        -:  300: * MSVCRT implementations are not ANSI C99 conformant...
        -:  301: * we offer these conforming alternatives from libmingwex.a
        -:  302: */
        -:  303:#undef  __mingw_stdio_redirect__
        -:  304:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __mingw_##F
        -:  305:
        -:  306:extern int __mingw_stdio_redirect__(fprintf)(FILE*, const char*, ...);
        -:  307:extern int __mingw_stdio_redirect__(printf)(const char*, ...);
        -:  308:extern int __mingw_stdio_redirect__(sprintf)(char*, const char*, ...);
        -:  309:extern int __mingw_stdio_redirect__(snprintf)(char*, size_t, const char*, ...);
        -:  310:extern int __mingw_stdio_redirect__(vfprintf)(FILE*, const char*, __VALIST);
        -:  311:extern int __mingw_stdio_redirect__(vprintf)(const char*, __VALIST);
        -:  312:extern int __mingw_stdio_redirect__(vsprintf)(char*, const char*, __VALIST);
        -:  313:extern int __mingw_stdio_redirect__(vsnprintf)(char*, size_t, const char*, __VALIST);
        -:  314:
        -:  315:/* When using these C99 conforming alternatives, we may wish to support
        -:  316: * some of Microsoft's quirky formatting options, even when they violate
        -:  317: * strict C99 conformance.
        -:  318: */
        -:  319:#define _MSVC_PRINTF_QUIRKS		0x0100U
        -:  320:#define _QUERY_MSVC_PRINTF_QUIRKS	~0U, 0U
        -:  321:#define _DISABLE_MSVC_PRINTF_QUIRKS	~_MSVC_PRINTF_QUIRKS, 0U
        -:  322:#define _ENABLE_MSVC_PRINTF_QUIRKS	~0U, _MSVC_PRINTF_QUIRKS
        -:  323:
        -:  324:/* Those quirks which conflict with ANSI C99 specified behaviour are
        -:  325: * disabled by default; use the following function, like this:
        -:  326: *
        -:  327: *   _mingw_output_format_control( _ENABLE_MSVC_PRINTF_QUIRKS );
        -:  328: *
        -:  329: * to enable them, like this:
        -:  330: *
        -:  331: *   state = _mingw_output_format_control( _QUERY_MSVC_PRINTF_QUIRKS )
        -:  332: *		& _MSVC_PRINTF_QUIRKS;
        -:  333: *
        -:  334: * to ascertain the currently active enabled state, or like this:
        -:  335: *
        -:  336: *   _mingw_output_format_control( _DISABLE_MSVC_PRINTF_QUIRKS );
        -:  337: *
        -:  338: * to disable them again.
        -:  339: */
        -:  340:extern unsigned int _mingw_output_format_control( unsigned int, unsigned int );
        -:  341:
        -:  342:#if __USE_MINGW_ANSI_STDIO
        -:  343:/* User has expressed a preference for C99 conformance...
        -:  344: */
        -:  345:# undef __mingw_stdio_redirect__
        -:  346:# ifdef __cplusplus
        -:  347:/* For C++ we use inline implementations, to avoid interference
        -:  348: * with namespace qualification, which may result from using #defines.
        -:  349: */
        -:  350:#  define __mingw_stdio_redirect__  inline __cdecl __MINGW_NOTHROW
        -:  351:
        -:  352:# elif defined __GNUC__
        -:  353:/* FIXME: Is there any GCC version prerequisite here?
        -:  354: *
        -:  355: * We also prefer inline implementations for C, when we can be confident
        -:  356: * that the GNU specific __inline__ mechanism is supported.
        -:  357: */
        -:  358:#  define __mingw_stdio_redirect__  static __inline__ __cdecl __MINGW_NOTHROW
        -:  359:
        -:  360:# else
        -:  361:/* Can't use inlines; fall back on module local static stubs.
        -:  362: */
        -:  363:#  define __mingw_stdio_redirect__  static __cdecl __MINGW_NOTHROW
        -:  364:# endif
        -:  365:
        -:  366:__mingw_stdio_redirect__
        -:  367:int fprintf (FILE *__stream, const char *__format, ...)
        -:  368:{
        -:  369:  register int __retval;
        -:  370:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  371:  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
        -:  372:  __builtin_va_end( __local_argv );
        -:  373:  return __retval;
        -:  374:}
        -:  375:
        -:  376:__mingw_stdio_redirect__
        8:  377:int printf (const char *__format, ...)
        -:  378:{
        -:  379:  register int __retval;
        8:  380:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        8:  381:  __retval = __mingw_vprintf( __format, __local_argv );
        8:  382:  __builtin_va_end( __local_argv );
        8:  383:  return __retval;
        -:  384:}
        -:  385:
        -:  386:__mingw_stdio_redirect__
        -:  387:int sprintf (char *__stream, const char *__format, ...)
        -:  388:{
        -:  389:  register int __retval;
        -:  390:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  391:  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
        -:  392:  __builtin_va_end( __local_argv );
        -:  393:  return __retval;
        -:  394:}
        -:  395:
        -:  396:__mingw_stdio_redirect__
        -:  397:int vfprintf (FILE *__stream, const char *__format, __VALIST __local_argv)
        -:  398:{
        -:  399:  return __mingw_vfprintf( __stream, __format, __local_argv );
        -:  400:}
        -:  401:
        -:  402:__mingw_stdio_redirect__
        -:  403:int vprintf (const char *__format, __VALIST __local_argv)
        -:  404:{
        -:  405:  return __mingw_vprintf( __format, __local_argv );
        -:  406:}
        -:  407:
        -:  408:__mingw_stdio_redirect__
        -:  409:int vsprintf (char *__stream, const char *__format, __VALIST __local_argv)
        -:  410:{
        -:  411:  return __mingw_vsprintf( __stream, __format, __local_argv );
        -:  412:}
        -:  413:
        -:  414:#else
        -:  415:/* Default configuration: simply direct all calls to MSVCRT...
        -:  416: */
        -:  417:_CRTIMP __cdecl __MINGW_NOTHROW  int fprintf (FILE *, const char *, ...);
        -:  418:_CRTIMP __cdecl __MINGW_NOTHROW  int printf (const char *, ...);
        -:  419:_CRTIMP __cdecl __MINGW_NOTHROW  int sprintf (char *, const char *, ...);
        -:  420:_CRTIMP __cdecl __MINGW_NOTHROW  int vfprintf (FILE *, const char *, __VALIST);
        -:  421:_CRTIMP __cdecl __MINGW_NOTHROW  int vprintf (const char *, __VALIST);
        -:  422:_CRTIMP __cdecl __MINGW_NOTHROW  int vsprintf (char *, const char *, __VALIST);
        -:  423:
        -:  424:#endif
        -:  425:/* Regardless of user preference, always offer these alternative
        -:  426: * entry points, for direct access to the MSVCRT implementations.
        -:  427: */
        -:  428:#undef  __mingw_stdio_redirect__
        -:  429:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __msvcrt_##F
        -:  430:
        -:  431:_CRTIMP int __mingw_stdio_redirect__(fprintf)(FILE *, const char *, ...);
        -:  432:_CRTIMP int __mingw_stdio_redirect__(printf)(const char *, ...);
        -:  433:_CRTIMP int __mingw_stdio_redirect__(sprintf)(char *, const char *, ...);
        -:  434:_CRTIMP int __mingw_stdio_redirect__(vfprintf)(FILE *, const char *, __VALIST);
        -:  435:_CRTIMP int __mingw_stdio_redirect__(vprintf)(const char *, __VALIST);
        -:  436:_CRTIMP int __mingw_stdio_redirect__(vsprintf)(char *, const char *, __VALIST);
        -:  437:
        -:  438:#undef  __mingw_stdio_redirect__
        -:  439:
        -:  440:/* The following three ALWAYS refer to the MSVCRT implementations...
        -:  441: */
        -:  442:_CRTIMP __cdecl __MINGW_NOTHROW  int _snprintf (char *, size_t, const char *, ...);
        -:  443:_CRTIMP __cdecl __MINGW_NOTHROW  int _vsnprintf (char *, size_t, const char *, __VALIST);
        -:  444:_CRTIMP __cdecl __MINGW_NOTHROW  int _vscprintf (const char *, __VALIST);
        -:  445:
        -:  446:#ifdef _ISOC99_SOURCE
        -:  447:/* Microsoft does not provide implementations for the following,
        -:  448: * which are required by C99.  Note in particular that Microsoft's
        -:  449: * corresponding implementations of _snprintf() and _vsnprintf() are
        -:  450: * NOT compatible with C99, but the following are; if you want the
        -:  451: * MSVCRT behaviour, you MUST use the Microsoft "uglified" names.
        -:  452: */
        -:  453:__cdecl __MINGW_NOTHROW  int snprintf (char *, size_t, const char *, ...);
        -:  454:__cdecl __MINGW_NOTHROW  int vsnprintf (char *, size_t, const char *, __VALIST);
        -:  455:
        -:  456:__cdecl __MINGW_NOTHROW  int vscanf (const char * __restrict__, __VALIST);
        -:  457:
        -:  458:__cdecl __MINGW_NOTHROW
        -:  459:int vfscanf (FILE * __restrict__, const char * __restrict__, __VALIST);
        -:  460:
        -:  461:__cdecl __MINGW_NOTHROW
        -:  462:int vsscanf (const char * __restrict__, const char * __restrict__, __VALIST);
        -:  463:
        -:  464:#endif  /* _ISOC99_SOURCE */
        -:  465:#endif	/* <stdio.h> included in its own right */
        -:  466:
        -:  467:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  468:/*
        -:  469: * In MSVCR80.DLL, (and its descendants), Microsoft introduced variants
        -:  470: * of the printf() functions, with names qualified by an underscore prefix
        -:  471: * and "_p" or "_p_l" suffixes; implemented in Microsoft's typically crass,
        -:  472: * non-standard, and non-portable fashion, these provide support for access
        -:  473: * to printf() arguments in random order, as was standardised by POSIX as a
        -:  474: * feature of the optional Extended Systems Interface (XSI) specification,
        -:  475: * and is now required for conformity with the POSIX.1-2008 base standard.
        -:  476: * Although these additional Microsoft functions were subsequently added
        -:  477: * to MSVCRT.DLL, from Windows-Vista onward, and they are prototyped here,
        -:  478: * MinGW applications are strenuously encouraged to avoid using them; a
        -:  479: * much better alternative is to "#define _XOPEN_SOURCE 700" before any
        -:  480: * system header is included, then use POSIX standard printf() functions
        -:  481: * instead; this is both portable to many non-Windows platforms, and it
        -:  482: * offers better compatibility with earlier Windows versions.
        -:  483: */
        -:  484:#ifndef __have_typedef_locale_t
        -:  485:/* Note that some of the following require the opaque locale_t data type,
        -:  486: * which we may obtain, by selective inclusion, from <locale.h>
        -:  487: */
        -:  488:#define __need_locale_t
        -:  489:#include <locale.h>
        -:  490:#endif
        -:  491:
        -:  492:#ifdef _STDIO_H
        -:  493:/* The following are to be declared only when <stdio.h> is explicitly
        -:  494: * included; the first six are NOT dependent on locale_t...
        -:  495: */
        -:  496:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  497:int _printf_p (const char *, ...);
        -:  498:
        -:  499:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  500:int _fprintf_p (FILE *, const char *, ...);
        -:  501:
        -:  502:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  503:int _sprintf_p (char *, size_t, const char *, ...);
        -:  504:
        -:  505:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  506:int _vprintf_p (const char *, __VALIST);
        -:  507:
        -:  508:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  509:int _vfprintf_p (FILE *, const char *, __VALIST);
        -:  510:
        -:  511:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  512:int _vsprintf_p (char *, size_t, const char *, __VALIST);
        -:  513:
        -:  514:/* ...whereas the following six DO depend on locale_t.
        -:  515: *
        -:  516: * CAVEAT: unless you are linking with non-free MSVCR80.DLL, or one
        -:  517: * of its later derivatives, good luck trying to use these; see the
        -:  518: * explanation in <locale.t>, as to why you may be unable to create,
        -:  519: * or otherwise acquire a reference to, a locale_t object.
        -:  520: */
        -:  521:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  522:int _printf_p_l (const char *, locale_t, ...);
        -:  523:
        -:  524:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  525:int _fprintf_p_l (FILE *, const char *, locale_t, ...);
        -:  526:
        -:  527:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  528:int _sprintf_p_l (char *, size_t, const char *, locale_t, ...);
        -:  529:
        -:  530:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  531:int _vprintf_p_l (const char *, locale_t, __VALIST);
        -:  532:
        -:  533:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  534:int _vfprintf_p_l (FILE *, const char *, locale_t, __VALIST);
        -:  535:
        -:  536:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  537:int _vsprintf_p_l (char *, size_t, const char *, locale_t, __VALIST);
        -:  538:
        -:  539:#endif	/* <stdio.h> included in its own right */
        -:  540:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  541:
        -:  542:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  543:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  544:/*
        -:  545: * Wide character variants of the foregoing "positional parameter" printf()
        -:  546: * functions; MSDN says that these should be declared when either <stdio.h>, or
        -:  547: * <wchar.h> is included, so we make them selectively available to <wchar.h>,
        -:  548: * but, just as in the foregoing, we advise against their use.
        -:  549: */
        -:  550:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  551:int _wprintf_p (const wchar_t *, ...);
        -:  552:
        -:  553:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  554:int _fwprintf_p (FILE *, const wchar_t *, ...);
        -:  555:
        -:  556:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  557:int _swprintf_p (wchar_t *, size_t, const wchar_t *, ...);
        -:  558:
        -:  559:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  560:int _vwprintf_p (const wchar_t *, __VALIST);
        -:  561:
        -:  562:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  563:int _vfwprintf_p (FILE *, const wchar_t *, __VALIST);
        -:  564:
        -:  565:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  566:int _vswprintf_p (wchar_t *, size_t, const wchar_t *, __VALIST);
        -:  567:
        -:  568:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  569:int _wprintf_p_l (const wchar_t *, locale_t, ...);
        -:  570:
        -:  571:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  572:int _fwprintf_p_l (FILE *, const wchar_t *, locale_t, ...);
        -:  573:
        -:  574:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  575:int _swprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, ...);
        -:  576:
        -:  577:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  578:int _vwprintf_p_l (const wchar_t *, locale_t, __VALIST);
        -:  579:
        -:  580:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  581:int _vfwprintf_p_l (FILE *, const wchar_t *, locale_t, __VALIST);
        -:  582:
        -:  583:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  584:int _vswprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, __VALIST);
        -:  585:
        -:  586:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  587:#endif	/* ! (defined _STDIO_H && defined _WCHAR_H) */
        -:  588:#ifdef _STDIO_H
        -:  589:/* Once again, back to <stdio.h> specific declarations.
        -:  590: *
        -:  591: *
        -:  592: * Formatted Input
        -:  593: */
        -:  594:_CRTIMP __cdecl __MINGW_NOTHROW  int    fscanf (FILE *, const char *, ...);
        -:  595:_CRTIMP __cdecl __MINGW_NOTHROW  int    scanf (const char *, ...);
        -:  596:_CRTIMP __cdecl __MINGW_NOTHROW  int    sscanf (const char *, const char *, ...);
        -:  597:
        -:  598:/* Character Input and Output Functions
        -:  599: */
        -:  600:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetc (FILE *);
        -:  601:_CRTIMP __cdecl __MINGW_NOTHROW  char * fgets (char *, int, FILE *);
        -:  602:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputc (int, FILE *);
        -:  603:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputs (const char *, FILE *);
        -:  604:_CRTIMP __cdecl __MINGW_NOTHROW  char * gets (char *);
        -:  605:_CRTIMP __cdecl __MINGW_NOTHROW  int    puts (const char *);
        -:  606:_CRTIMP __cdecl __MINGW_NOTHROW  int    ungetc (int, FILE *);
        -:  607:
        -:  608:/* Traditionally, getc and putc are defined as macros. but the
        -:  609: * standard doesn't say that they must be macros.  We use inline
        -:  610: * functions here to allow the fast versions to be used in C++
        -:  611: * with namespace qualification, eg., ::getc.
        -:  612: *
        -:  613: * NOTE: _filbuf and _flsbuf  are not thread-safe.
        -:  614: */
        -:  615:_CRTIMP __cdecl __MINGW_NOTHROW  int   _filbuf (FILE *);
        -:  616:_CRTIMP __cdecl __MINGW_NOTHROW  int   _flsbuf (int, FILE *);
        -:  617:
        -:  618:#if !defined _MT
        -:  619:
        -:  620:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE *);
        -:  621:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE * __F)
        -:  622:{
        -:  623:  return (--__F->_cnt >= 0)
        -:  624:    ?  (int) (unsigned char) *__F->_ptr++
        -:  625:    : _filbuf (__F);
        -:  626:}
        -:  627:
        -:  628:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int, FILE *);
        -:  629:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int __c, FILE * __F)
        -:  630:{
        -:  631:  return (--__F->_cnt >= 0)
        -:  632:    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
        -:  633:    :  _flsbuf (__c, __F);
        -:  634:}
        -:  635:
        -:  636:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void);
        -:  637:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void)
        -:  638:{
        -:  639:  return (--stdin->_cnt >= 0)
        -:  640:    ?  (int) (unsigned char) *stdin->_ptr++
        -:  641:    : _filbuf (stdin);
        -:  642:}
        -:  643:
        -:  644:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int);
        -:  645:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int __c)
        -:  646:{
        -:  647:  return (--stdout->_cnt >= 0)
        -:  648:    ?  (int) (unsigned char) (*stdout->_ptr++ = (char)__c)
        -:  649:    :  _flsbuf (__c, stdout);}
        -:  650:
        -:  651:#else  /* Use library functions.  */
        -:  652:
        -:  653:_CRTIMP __cdecl __MINGW_NOTHROW  int    getc (FILE *);
        -:  654:_CRTIMP __cdecl __MINGW_NOTHROW  int    putc (int, FILE *);
        -:  655:_CRTIMP __cdecl __MINGW_NOTHROW  int    getchar (void);
        -:  656:_CRTIMP __cdecl __MINGW_NOTHROW  int    putchar (int);
        -:  657:
        -:  658:#endif
        -:  659:
        -:  660:/* Direct Input and Output Functions
        -:  661: */
        -:  662:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fread (void *, size_t, size_t, FILE *);
        -:  663:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fwrite (const void *, size_t, size_t, FILE *);
        -:  664:
        -:  665:/* File Positioning Functions
        -:  666: */
        -:  667:_CRTIMP __cdecl __MINGW_NOTHROW  int    fseek (FILE *, long, int);
        -:  668:_CRTIMP __cdecl __MINGW_NOTHROW  long   ftell (FILE *);
        -:  669:_CRTIMP __cdecl __MINGW_NOTHROW  void   rewind (FILE *);
        -:  670:
        -:  671:#if _WIN32_WINNT >= _WIN32_WINNT_VISTA || __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  672: /*
        -:  673:  * Microsoft introduced a number of variations on fseek() and ftell(),
        -:  674:  * beginning with MSVCR80.DLL; the bare _fseeki64() and _ftelli64() were
        -:  675:  * subsequently integrated into MSVCRT.DLL, from Vista onward...
        -:  676:  */
        -:  677:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64 (FILE *, __int64, int);
        -:  678:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64 (FILE *);
        -:  679:
        -:  680:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  681: /*
        -:  682:  * ...while the "nolock" variants remain exclusive to MSVCR80.DLL, and
        -:  683:  * its later MSVC specific derivatives.
        -:  684:  */
        -:  685:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseek_nolock (FILE *, long, int);
        -:  686:_CRTIMP __cdecl __MINGW_NOTHROW  long   _ftell_nolock (FILE *);
        -:  687:
        -:  688:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64_nolock (FILE *, __int64, int);
        -:  689:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64_nolock (FILE *);
        -:  690:
        -:  691:#endif  /* MSVCR80.DLL and later derivatives ONLY */
        -:  692:#endif  /* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  693:
        -:  694:#ifdef __USE_MINGW_FSEEK
        -:  695:/* Workaround for a limitation on Win9x where a file is not zero padded
        -:  696: * on write, following a seek beyond the original end of file; these are
        -:  697: * implemented in libmingwex.a
        -:  698: */
        -:  699:__cdecl __MINGW_NOTHROW  int    __mingw_fseek (FILE *, long, int);
        -:  700:__cdecl __MINGW_NOTHROW  size_t __mingw_fwrite (const void *, size_t, size_t, FILE *);
        -:  701:
        -:  702:#define fwrite(buffer, size, count, fp)  __mingw_fwrite(buffer, size, count, fp)
        -:  703:#define fseek(fp, offset, whence)        __mingw_fseek(fp, offset, whence)
        -:  704:#endif /* __USE_MINGW_FSEEK */
        -:  705:
        -:  706:/* An opaque data type used for storing file positions... The contents of
        -:  707: * this type are unknown, but we (the compiler) need to know the size
        -:  708: * because the programmer using fgetpos and fsetpos will be setting aside
        -:  709: * storage for fpos_t structres. Actually I tested using a byte array and
        -:  710: * it is fairly evident that the fpos_t type is a long (in CRTDLL.DLL).
        -:  711: * Perhaps an unsigned long? TODO? It's definitely a 64-bit number in
        -:  712: * MSVCRT however, and for now `long long' will do.
        -:  713: */
        -:  714:#ifdef __MSVCRT__
        -:  715:typedef long long  fpos_t;
        -:  716:#else
        -:  717:typedef long       fpos_t;
        -:  718:#endif
        -:  719:
        -:  720:_CRTIMP __cdecl __MINGW_NOTHROW  int fgetpos (FILE *, fpos_t *);
        -:  721:_CRTIMP __cdecl __MINGW_NOTHROW  int fsetpos (FILE *, const fpos_t *);
        -:  722:
        -:  723:/* Error Functions
        -:  724: */
        -:  725:_CRTIMP __cdecl __MINGW_NOTHROW  int feof (FILE *);
        -:  726:_CRTIMP __cdecl __MINGW_NOTHROW  int ferror (FILE *);
        -:  727:
        -:  728:#ifdef __cplusplus
        -:  729:inline __cdecl __MINGW_NOTHROW  int feof (FILE * __F){ return __F->_flag & _IOEOF; }
        -:  730:inline __cdecl __MINGW_NOTHROW  int ferror (FILE * __F){ return __F->_flag & _IOERR; }
        -:  731:#else
        -:  732:#define feof(__F)     ((__F)->_flag & _IOEOF)
        -:  733:#define ferror(__F)   ((__F)->_flag & _IOERR)
        -:  734:#endif
        -:  735:
        -:  736:_CRTIMP __cdecl __MINGW_NOTHROW  void clearerr (FILE *);
        -:  737:_CRTIMP __cdecl __MINGW_NOTHROW  void perror (const char *);
        -:  738:
        -:  739:
        -:  740:#ifndef __STRICT_ANSI__
        -:  741:/*
        -:  742: * Pipes
        -:  743: */
        -:  744:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _popen (const char *, const char *);
        -:  745:_CRTIMP __cdecl __MINGW_NOTHROW  int    _pclose (FILE *);
        -:  746:
        -:  747:#ifndef NO_OLDNAMES
        -:  748:_CRTIMP __cdecl __MINGW_NOTHROW  FILE *  popen (const char *, const char *);
        -:  749:_CRTIMP __cdecl __MINGW_NOTHROW  int     pclose (FILE *);
        -:  750:#endif
        -:  751:
        -:  752:/* Other Non ANSI functions
        -:  753: */
        -:  754:_CRTIMP __cdecl __MINGW_NOTHROW  int    _flushall (void);
        -:  755:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fgetchar (void);
        -:  756:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fputchar (int);
        -:  757:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fdopen (int, const char *);
        -:  758:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fileno (FILE *);
        -:  759:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fcloseall (void);
        -:  760:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fsopen (const char *, const char *, int);
        -:  761:#ifdef __MSVCRT__
        -:  762:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getmaxstdio (void);
        -:  763:_CRTIMP __cdecl __MINGW_NOTHROW  int    _setmaxstdio (int);
        -:  764:#endif
        -:  765:
        -:  766:/* Microsoft introduced a capability in MSVCR80.DLL and later, to
        -:  767: * set the minimum number of digits to be displayed in a printf()
        -:  768: * floating point exponent; they retro-fitted this in MSVCRT.DLL,
        -:  769: * from Windows-Vista onwards, but we provide our own wrappers in
        -:  770: * libmingwex.a, which make it possible for us to emulate the API
        -:  771: * for any version of MSVCRT.DLL (including WinXP and earlier).
        -:  772: */
        -:  773:#define _TWO_DIGIT_EXPONENT    1
        -:  774:
        -:  775:/* While Microsoft define the preceding manifest constant, they
        -:  776: * appear to neglect to define its complement, (for restoration
        -:  777: * of their default exponent display format); for orthogonality,
        -:  778: * we will provide this regardless of Microsoft's negligence.
        -:  779: */
        -:  780:#define _THREE_DIGIT_EXPONENT  0
        -:  781:
        -:  782:/* Once again, unspecified by Microsoft, (and mostly redundant),
        -:  783: * it is convenient to specify a combining mask for these.
        -:  784: */
        -:  785:#define _EXPONENT_DIGIT_MASK  (_TWO_DIGIT_EXPONENT | _THREE_DIGIT_EXPONENT)
        -:  786:
        -:  787:unsigned int __cdecl __mingw_get_output_format (void);
        -:  788:unsigned int __cdecl __mingw_set_output_format (unsigned int);
        -:  789:
        -:  790:/* Also appearing for the first time in MSVCR80.DLL, and then also
        -:  791: * retro-fitted to MSVCRT.DLL from Windows-Vista onwards, was this
        -:  792: * pair of functions to control availability of "%n" formatting in
        -:  793: * the MSVCRT.DLL printf() family of functions, for which we also
        -:  794: * provide our own DLL version agnostic wrappers:
        -:  795: */
        -:  796:int __cdecl __mingw_get_printf_count_output (void);
        -:  797:int __cdecl __mingw_set_printf_count_output (int);
        -:  798:
        -:  799:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  800:/* When the user declares that MSVCR80.DLL features are supported,
        -:  801: * we simply expose the corresponding APIs...
        -:  802: */
        -:  803:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _get_output_format (void);
        -:  804:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _set_output_format (unsigned int);
        -:  805:
        -:  806:_CRTIMP __cdecl __MINGW_NOTHROW  int _get_printf_count_output (void);
        -:  807:_CRTIMP __cdecl __MINGW_NOTHROW  int _set_printf_count_output (int);
        -:  808:
        -:  809:#else
        -:  810:/* ...otherwise, we emulate the APIs, in a DLL version agnostic
        -:  811: * manner, using our own implementation wrappers.
        -:  812: */
        -:  813:__CRT_ALIAS unsigned int __cdecl _get_output_format (void)
        -:  814:{ return __mingw_get_output_format (); }
        -:  815:
        -:  816:__CRT_ALIAS unsigned int __cdecl _set_output_format (unsigned int __style)
        -:  817:{ return __mingw_set_output_format (__style); }
        -:  818:
        -:  819:/* When using our own printf() implementation, "%n" format is ALWAYS
        -:  820: * supported, so we make this API a no-op, reporting it to be so; for
        -:  821: * the alternative case, when using MSVCRT.DLL's printf(), we delegate
        -:  822: * to our wrapper API implementation, which will invoke the API function
        -:  823: * calls within the DLL, if they are available, or persistently report
        -:  824: * the state of "%n" formatting as DISABLED if they are not.
        -:  825: */
        -:  826:#if __USE_MINGW_ANSI_STDIO
        -:  827:/* Note that __USE_MINGW_ANSI_STDIO is not guaranteed to resolve to any
        -:  828: * symbol which will represent a compilable logic state; map it to this
        -:  829: * alternative which will, for the true state...
        -:  830: */
        -:  831:# define __USE_MINGW_PRINTF  1
        -:  832:#else
        -:  833:/* ...and for the false.
        -:  834: */
        -:  835:# define __USE_MINGW_PRINTF  0
        -:  836:#endif
        -:  837:
        -:  838:__CRT_ALIAS int __cdecl _get_printf_count_output (void)
        -:  839:{ return __USE_MINGW_PRINTF ? 1 : __mingw_get_printf_count_output (); }
        -:  840:
        -:  841:__CRT_ALIAS int __cdecl _set_printf_count_output (int __mode)
        -:  842:{ return __USE_MINGW_PRINTF ? 1 : __mingw_set_printf_count_output (__mode); }
        -:  843:#endif
        -:  844:
        -:  845:#ifndef _NO_OLDNAMES
        -:  846:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetchar (void);
        -:  847:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputchar (int);
        -:  848:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fdopen (int, const char *);
        -:  849:_CRTIMP __cdecl __MINGW_NOTHROW  int    fileno (FILE *);
        -:  850:#endif	/* !_NO_OLDNAMES */
        -:  851:
        -:  852:#define _fileno(__F) ((__F)->_file)
        -:  853:#ifndef _NO_OLDNAMES
        -:  854:#define fileno(__F) ((__F)->_file)
        -:  855:#endif
        -:  856:
        -:  857:#if defined (__MSVCRT__) && ! defined (__NO_MINGW_LFS)
        -:  858:__CRT_ALIAS FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char *, const char *);
        -:  859:__CRT_ALIAS __JMPSTUB__(( FUNCTION = fopen64, REMAPPED = fopen ))
        -:  860:FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char * filename, const char * mode)
        -:  861:{ return fopen (filename, mode); }
        -:  862:
        -:  863:int __cdecl __MINGW_NOTHROW  fseeko64 (FILE *, __off64_t, int);
        -:  864:
        -:  865:#ifdef __USE_MINGW_FSEEK
        -:  866:int __cdecl __MINGW_NOTHROW __mingw_fseeko64 (FILE *, __off64_t, int);
        -:  867:#define fseeko64(fp, offset, whence)  __mingw_fseeko64(fp, offset, whence)
        -:  868:#endif
        -:  869:
        -:  870:__CRT_ALIAS __off64_t __cdecl __MINGW_NOTHROW ftello64 (FILE *);
        -:  871:__CRT_ALIAS __LIBIMPL__(( FUNCTION = ftello64 ))
        -:  872:__off64_t __cdecl __MINGW_NOTHROW ftello64 (FILE * stream)
        -:  873:{ fpos_t __pos; return (fgetpos(stream, &__pos)) ? -1LL : (__off64_t)(__pos); }
        -:  874:
        -:  875:#endif	/* __MSVCRT__ && !__NO_MINGW_LFS */
        -:  876:#endif	/* !__STRICT_ANSI__ */
        -:  877:#endif	/* _STDIO_H */
        -:  878:
        -:  879:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  880:/* The following are declared when including either <stdio.h> or <wchar.h>.
        -:  881: * If both header include guards are now in place, then we must currently be
        -:  882: * including <stdio.h> in its own right, having already processed this block
        -:  883: * during prior partial inclusion by <wchar.h>; there is no need to process
        -:  884: * it a second time.
        -:  885: */
        -:  886:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwprintf (FILE *, const wchar_t *, ...);
        -:  887:_CRTIMP __cdecl __MINGW_NOTHROW  int     wprintf (const wchar_t *, ...);
        -:  888:_CRTIMP __cdecl __MINGW_NOTHROW  int     vfwprintf (FILE *, const wchar_t *, __VALIST);
        -:  889:_CRTIMP __cdecl __MINGW_NOTHROW  int     vwprintf (const wchar_t *, __VALIST);
        -:  890:_CRTIMP __cdecl __MINGW_NOTHROW  int    _snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -:  891:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vscwprintf (const wchar_t *, __VALIST);
        -:  892:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -:  893:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwscanf (FILE *, const wchar_t *, ...);
        -:  894:_CRTIMP __cdecl __MINGW_NOTHROW  int     wscanf (const wchar_t *, ...);
        -:  895:_CRTIMP __cdecl __MINGW_NOTHROW  int     swscanf (const wchar_t *, const wchar_t *, ...);
        -:  896:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwc (FILE *);
        -:  897:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwc (wchar_t, FILE *);
        -:  898:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  ungetwc (wchar_t, FILE *);
        -:  899:
        -:  900:#ifndef __STRICT_ANSI__
        -:  901:/* These differ from the ISO C prototypes, which have a maxlen parameter (like snprintf).
        -:  902: */
        -:  903:_CRTIMP __cdecl __MINGW_NOTHROW  int  swprintf (wchar_t *, const wchar_t *, ...);
        -:  904:_CRTIMP __cdecl __MINGW_NOTHROW  int  vswprintf (wchar_t *, const wchar_t *, __VALIST);
        -:  905:#endif
        -:  906:
        -:  907:#ifdef __MSVCRT__
        -:  908:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * fgetws (wchar_t *, int, FILE *);
        -:  909:_CRTIMP __cdecl __MINGW_NOTHROW  int       fputws (const wchar_t *, FILE *);
        -:  910:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwc (FILE *);
        -:  911:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwchar (void);
        -:  912:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwc (wint_t, FILE *);
        -:  913:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwchar (wint_t);
        -:  914:
        -:  915:#ifndef __STRICT_ANSI__
        -:  916:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _getws (wchar_t *);
        -:  917:_CRTIMP __cdecl __MINGW_NOTHROW  int       _putws (const wchar_t *);
        -:  918:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfdopen(int, const wchar_t *);
        -:  919:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfopen (const wchar_t *, const wchar_t *);
        -:  920:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfreopen (const wchar_t *, const wchar_t *, FILE *);
        -:  921:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfsopen (const wchar_t *, const wchar_t *, int);
        -:  922:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtmpnam (wchar_t *);
        -:  923:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtempnam (const wchar_t *, const wchar_t *);
        -:  924:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wrename (const wchar_t *, const wchar_t *);
        -:  925:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wremove (const wchar_t *);
        -:  926:_CRTIMP __cdecl __MINGW_NOTHROW  void      _wperror (const wchar_t *);
        -:  927:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wpopen (const wchar_t *, const wchar_t *);
        -:  928:
        -:  929:#endif  /* !__STRICT_ANSI__ */
        -:  930:#endif	/* __MSVCRT__ */
        -:  931:
        -:  932:#ifdef _ISOC99_SOURCE
        -:  933:__cdecl __MINGW_NOTHROW  int snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -:  934:__cdecl __MINGW_NOTHROW  int vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -:  935:
        -:  936:#ifndef __NO_INLINE__
        -:  937:__CRT_INLINE __cdecl __MINGW_NOTHROW
        -:  938:__JMPSTUB__(( FUNCTION = vsnwprintf, REMAPPED = _vsnwprintf ))
        -:  939:int vsnwprintf (wchar_t *__s, size_t __n, const wchar_t *__fmt, __VALIST __arg)
        -:  940:{ return _vsnwprintf ( __s, __n, __fmt, __arg); }
        -:  941:#endif
        -:  942:
        -:  943:__cdecl __MINGW_NOTHROW  int  vwscanf (const wchar_t *__restrict__, __VALIST);
        -:  944:__cdecl __MINGW_NOTHROW
        -:  945:int  vfwscanf (FILE *__restrict__, const wchar_t *__restrict__, __VALIST);
        -:  946:__cdecl __MINGW_NOTHROW
        -:  947:int  vswscanf (const wchar_t *__restrict__, const wchar_t * __restrict__, __VALIST);
        -:  948:
        -:  949:#endif  /* _ISOC99_SOURCE */
        -:  950:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -:  951:
        -:  952:#if defined _STDIO_H && ! defined __STRICT_ANSI__
        -:  953:#if defined __MSVCRT__ && ! defined _NO_OLDNAMES
        -:  954:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * wpopen (const wchar_t *, const wchar_t *);
        -:  955:#endif
        -:  956:
        -:  957:/* Other non-ANSI wide character functions...
        -:  958: */
        -:  959:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fgetwchar (void);
        -:  960:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fputwchar (wint_t);
        -:  961:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getw (FILE *);
        -:  962:_CRTIMP __cdecl __MINGW_NOTHROW  int    _putw (int, FILE *);
        -:  963:
        -:  964:#ifndef _NO_OLDNAMES
        -:  965:/* ...and their original names, before Microsoft uglification...
        -:  966: */
        -:  967:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwchar (void);
        -:  968:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwchar (wint_t);
        -:  969:_CRTIMP __cdecl __MINGW_NOTHROW  int     getw (FILE *);
        -:  970:_CRTIMP __cdecl __MINGW_NOTHROW  int     putw (int, FILE *);
        -:  971:
        -:  972:#endif  /* !_NO_OLDNAMES */
        -:  973:#endif  /* !__STRICT_ANSI__ */
        -:  974:
        -:  975:_END_C_DECLS
        -:  976:
        -:  977:#endif	/* ! RC_INVOKED */
        -:  978:#endif  /* !_STDIO_H: $RCSfile: stdio.h,v $: end of file */
